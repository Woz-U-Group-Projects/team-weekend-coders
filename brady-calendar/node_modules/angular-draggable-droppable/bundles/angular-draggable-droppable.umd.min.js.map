{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://angular-draggable-droppable/lib/draggable-helper.provider.ts","ng://angular-draggable-droppable/lib/draggable-scroll-container.directive.ts","ng://angular-draggable-droppable/lib/draggable.directive.ts","ng://angular-draggable-droppable/lib/droppable.directive.ts","ng://angular-draggable-droppable/lib/drag-and-drop.module.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","DraggableHelper","Subject","Injectable","args","providedIn","DraggableScrollContainerDirective","elementRef","renderer","zone","duration","delta","ngOnInit","_this","runOutsideAngular","listen","nativeElement","event","cancelledScroll","cancelable","preventDefault","disableScroll","setStyle","enableScroll","hasScrollbar","containerHasHorizontalScroll","scrollWidth","clientWidth","containerHasVerticalScroll","scrollHeight","clientHeight","Directive","selector","ElementRef","Renderer2","NgZone","Input","DraggableDirective","element","draggableHelper","vcr","scrollContainer","document","x","y","EventEmitter","timerBegin","timerEnd","checkEventListeners","pointerDragged$","pointerDown$","pipe","filter","canDrag","mergeMap","pointerDownEvent","stopPropagation","globalDragStyle","createElement","setAttribute","appendChild","createText","head","startScrollPosition","getScrollPosition","scrollContainerScroll$","Observable","observer","startWith","map","currentDrag$","cancelDrag$","ReplaySubject","run","dragPointerDown","dragComplete$","merge","pointerUp$","destroy$","share","pointerMove","combineLatest","pointerMove$","_a","_b","pointerMoveEvent","scroll","transformX","clientX","transformY","clientY","scrollLeft","left","scrollTop","top","moveData","dragSnapGrid","Math","round","dragAxis","scrollX","scrollY","validateDrag","takeUntil","dragStarted$","take","dragEnded$","takeLast","subscribe","dragStart","addClass","dragActiveClass","ghostDragEnabled","rect","getBoundingClientRect","clone_1","cloneNode","showOriginalElementWhileDragging","ghostElementAppendTo","insertBefore","nextSibling","ghostElement","setElementStyles","position","width","height","cursor","dragCursor","margin","ghostElementTemplate","viewRef_1","createEmbeddedView","innerHTML","rootNodes","node","Node","forEach","remove","indexOf","ghostElementCreated","emit","removeChild","currentDrag","dragEndData","dragEndData$","count","calledCount","dragCancelled","complete","dragEnd","removeClass","pairwise","previous","dragging","transform","-webkit-transform","-ms-transform","-moz-transform","-o-transform","dropData","ngOnChanges","changes","ngOnDestroy","unsubscribeEventListeners","hasEventListeners","keys","eventListenerSubscriptions","mousedown","onMouseDown","mouseup","onMouseUp","touchstart","onTouchStart","touchend","onTouchEnd","touchcancel","mouseenter","onMouseEnter","mouseleave","onMouseLeave","mousemove","mouseMoveEvent","hasContainerScrollbar","isDragActivated","activeLongPressDrag","timeLongPress","Date","now","touchmove","touchMoveEvent","shouldBeginDrag","targetTouches","touches","changedTouches","setCursor","type","styles","key","window","pageYOffset","documentElement","pageXOffset","moveScrollPosition","deltaScroll","abs","longPressConfig","ViewContainerRef","decorators","Optional","Inject","DOCUMENT","Output","isCoordinateWithinRectangle","right","bottom","DroppableDirective","currentDragSubscription","drag$","currentDragDropData","dragOverActive","droppableElement","updateCache","deregisterScrollListener","overlaps$","scrollContainerRect","isWithinElement","overlapsChanged$","distinctUntilChanged","overlapsNow","dragOverClass","dragEnter","dragOver","didOverlap","dragLeave","drop","unsubscribe","DragAndDropModule","NgModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\n\nexport interface CurrentDragData {\n  clientX: number;\n  clientY: number;\n  dropData: any;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DraggableHelper {\n  currentDrag = new Subject<Subject<CurrentDragData>>();\n}\n","import {\n  Directive,\n  ElementRef,\n  Input,\n  NgZone,\n  OnInit,\n  Renderer2\n} from '@angular/core';\n\n@Directive({\n  selector: '[mwlDraggableScrollContainer]'\n})\nexport class DraggableScrollContainerDirective implements OnInit {\n  /**\n   * Trigger the DragStart after a long touch in scrollable container when true\n   */\n  @Input()\n  activeLongPressDrag: boolean = false;\n\n  /**\n   * Configuration of a long touch\n   * Duration in ms of a long touch before activating DragStart\n   * Delta of the\n   */\n  @Input()\n  longPressConfig = { duration: 300, delta: 30 };\n\n  private cancelledScroll = false;\n\n  constructor(\n    public elementRef: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private zone: NgZone\n  ) {}\n\n  ngOnInit() {\n    this.zone.runOutsideAngular(() => {\n      this.renderer.listen(\n        this.elementRef.nativeElement,\n        'touchmove',\n        (event: TouchEvent) => {\n          if (this.cancelledScroll && event.cancelable) {\n            event.preventDefault();\n          }\n        }\n      );\n    });\n  }\n\n  disableScroll(): void {\n    this.cancelledScroll = true;\n    this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'hidden');\n  }\n\n  enableScroll(): void {\n    this.cancelledScroll = false;\n    this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'auto');\n  }\n\n  hasScrollbar(): boolean {\n    const containerHasHorizontalScroll =\n      this.elementRef.nativeElement.scrollWidth -\n        this.elementRef.nativeElement.clientWidth >\n      0;\n    const containerHasVerticalScroll =\n      this.elementRef.nativeElement.scrollHeight -\n        this.elementRef.nativeElement.clientHeight >\n      0;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  Renderer2,\n  Output,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnChanges,\n  NgZone,\n  SimpleChanges,\n  Inject,\n  TemplateRef,\n  ViewContainerRef,\n  Optional\n} from '@angular/core';\nimport { Subject, Observable, merge, ReplaySubject, combineLatest } from 'rxjs';\nimport {\n  map,\n  mergeMap,\n  takeUntil,\n  take,\n  takeLast,\n  pairwise,\n  share,\n  filter,\n  count,\n  startWith\n} from 'rxjs/operators';\nimport { CurrentDragData, DraggableHelper } from './draggable-helper.provider';\nimport { DOCUMENT } from '@angular/common';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface DragAxis {\n  x: boolean;\n  y: boolean;\n}\n\nexport interface SnapGrid {\n  x?: number;\n  y?: number;\n}\n\nexport interface DragPointerDownEvent extends Coordinates {}\n\nexport interface DragStartEvent {\n  cancelDrag$: ReplaySubject<void>;\n}\n\nexport interface DragMoveEvent extends Coordinates {}\n\nexport interface DragEndEvent extends Coordinates {\n  dragCancelled: boolean;\n}\n\nexport type ValidateDrag = (coordinates: Coordinates) => boolean;\n\nexport interface PointerEvent {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\nexport interface TimeLongPress {\n  timerBegin: number;\n  timerEnd: number;\n}\n\nexport interface GhostElementCreatedEvent {\n  clientX: number;\n  clientY: number;\n  element: HTMLElement;\n}\n\n@Directive({\n  selector: '[mwlDraggable]'\n})\nexport class DraggableDirective implements OnInit, OnChanges, OnDestroy {\n  /**\n   * an object of data you can pass to the drop event\n   */\n  @Input()\n  dropData: any;\n\n  /**\n   * The axis along which the element is draggable\n   */\n  @Input()\n  dragAxis: DragAxis = { x: true, y: true };\n\n  /**\n   * Snap all drags to an x / y grid\n   */\n  @Input()\n  dragSnapGrid: SnapGrid = {};\n\n  /**\n   * Show a ghost element that shows the drag when dragging\n   */\n  @Input()\n  ghostDragEnabled: boolean = true;\n\n  /**\n   * Show the original element when ghostDragEnabled is true\n   */\n  @Input()\n  showOriginalElementWhileDragging: boolean = false;\n\n  /**\n   * Allow custom behaviour to control when the element is dragged\n   */\n  @Input()\n  validateDrag: ValidateDrag;\n\n  /**\n   * The cursor to use when dragging the element\n   */\n  @Input()\n  dragCursor: string = '';\n\n  /**\n   * The css class to apply when the element is being dragged\n   */\n  @Input()\n  dragActiveClass: string;\n\n  /**\n   * The element the ghost element will be appended to. Default is next to the dragged element\n   */\n  @Input()\n  ghostElementAppendTo: HTMLElement;\n\n  /**\n   * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.\n   */\n  @Input()\n  ghostElementTemplate: TemplateRef<any>;\n\n  /**\n   * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n   */\n  @Output()\n  dragPointerDown = new EventEmitter<DragPointerDownEvent>();\n\n  /**\n   * Called when the element has started to be dragged.\n   * Only called after at least one mouse or touch move event.\n   * If you call $event.cancelDrag$.emit() it will cancel the current drag\n   */\n  @Output()\n  dragStart = new EventEmitter<DragStartEvent>();\n\n  /**\n   * Called after the ghost element has been created\n   */\n  @Output()\n  ghostElementCreated = new EventEmitter<GhostElementCreatedEvent>();\n\n  /**\n   * Called when the element is being dragged\n   */\n  @Output()\n  dragging = new EventEmitter<DragMoveEvent>();\n\n  /**\n   * Called after the element is dragged\n   */\n  @Output()\n  dragEnd = new EventEmitter<DragEndEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerDown$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerMove$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerUp$ = new Subject<PointerEvent>();\n\n  private eventListenerSubscriptions: {\n    mousemove?: () => void;\n    mousedown?: () => void;\n    mouseup?: () => void;\n    mouseenter?: () => void;\n    mouseleave?: () => void;\n    touchstart?: () => void;\n    touchmove?: () => void;\n    touchend?: () => void;\n    touchcancel?: () => void;\n  } = {};\n\n  private ghostElement: HTMLElement | null;\n\n  private destroy$ = new Subject();\n\n  private timeLongPress: TimeLongPress = { timerBegin: 0, timerEnd: 0 };\n\n  /**\n   * @hidden\n   */\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private vcr: ViewContainerRef,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective,\n    @Inject(DOCUMENT) private document: any\n  ) {}\n\n  ngOnInit(): void {\n    this.checkEventListeners();\n\n    const pointerDragged$: Observable<any> = this.pointerDown$.pipe(\n      filter(() => this.canDrag()),\n      mergeMap((pointerDownEvent: PointerEvent) => {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        }\n\n        // hack to prevent text getting selected in safari while dragging\n        const globalDragStyle: HTMLStyleElement = this.renderer.createElement(\n          'style'\n        );\n        this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n        this.renderer.appendChild(\n          globalDragStyle,\n          this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `)\n        );\n        this.document.head.appendChild(globalDragStyle);\n\n        const startScrollPosition = this.getScrollPosition();\n\n        const scrollContainerScroll$ = new Observable(observer => {\n          const scrollContainer = this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window';\n          return this.renderer.listen(scrollContainer, 'scroll', e =>\n            observer.next(e)\n          );\n        }).pipe(\n          startWith(startScrollPosition),\n          map(() => this.getScrollPosition())\n        );\n\n        const currentDrag$ = new Subject<CurrentDragData>();\n        const cancelDrag$ = new ReplaySubject<void>();\n\n        this.zone.run(() => {\n          this.dragPointerDown.next({ x: 0, y: 0 });\n        });\n\n        const dragComplete$ = merge(\n          this.pointerUp$,\n          this.pointerDown$,\n          cancelDrag$,\n          this.destroy$\n        ).pipe(share());\n\n        const pointerMove = combineLatest<\n          PointerEvent,\n          { top: number; left: number }\n        >(this.pointerMove$, scrollContainerScroll$).pipe(\n          map(([pointerMoveEvent, scroll]) => {\n            return {\n              currentDrag$,\n              transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n              transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n              clientX: pointerMoveEvent.clientX,\n              clientY: pointerMoveEvent.clientY,\n              scrollLeft: scroll.left,\n              scrollTop: scroll.top\n            };\n          }),\n          map(moveData => {\n            if (this.dragSnapGrid.x) {\n              moveData.transformX =\n                Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                this.dragSnapGrid.x;\n            }\n\n            if (this.dragSnapGrid.y) {\n              moveData.transformY =\n                Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                this.dragSnapGrid.y;\n            }\n\n            return moveData;\n          }),\n          map(moveData => {\n            if (!this.dragAxis.x) {\n              moveData.transformX = 0;\n            }\n\n            if (!this.dragAxis.y) {\n              moveData.transformY = 0;\n            }\n\n            return moveData;\n          }),\n          map(moveData => {\n            const scrollX = moveData.scrollLeft - startScrollPosition.left;\n            const scrollY = moveData.scrollTop - startScrollPosition.top;\n            return {\n              ...moveData,\n              x: moveData.transformX + scrollX,\n              y: moveData.transformY + scrollY\n            };\n          }),\n          filter(\n            ({ x, y }) => !this.validateDrag || this.validateDrag({ x, y })\n          ),\n          takeUntil(dragComplete$),\n          share()\n        );\n\n        const dragStarted$ = pointerMove.pipe(\n          take(1),\n          share()\n        );\n        const dragEnded$ = pointerMove.pipe(\n          takeLast(1),\n          share()\n        );\n\n        dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n          this.zone.run(() => {\n            this.dragStart.next({ cancelDrag$ });\n          });\n\n          this.renderer.addClass(\n            this.element.nativeElement,\n            this.dragActiveClass\n          );\n\n          if (this.ghostDragEnabled) {\n            const rect = this.element.nativeElement.getBoundingClientRect();\n            const clone = this.element.nativeElement.cloneNode(\n              true\n            ) as HTMLElement;\n            if (!this.showOriginalElementWhileDragging) {\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                'hidden'\n              );\n            }\n\n            if (this.ghostElementAppendTo) {\n              this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              this.element.nativeElement.parentNode!.insertBefore(\n                clone,\n                this.element.nativeElement.nextSibling\n              );\n            }\n\n            this.ghostElement = clone;\n\n            this.setElementStyles(clone, {\n              position: 'fixed',\n              top: `${rect.top}px`,\n              left: `${rect.left}px`,\n              width: `${rect.width}px`,\n              height: `${rect.height}px`,\n              cursor: this.dragCursor,\n              margin: '0'\n            });\n\n            if (this.ghostElementTemplate) {\n              const viewRef = this.vcr.createEmbeddedView(\n                this.ghostElementTemplate\n              );\n              clone.innerHTML = '';\n              viewRef.rootNodes\n                .filter(node => node instanceof Node)\n                .forEach(node => {\n                  clone.appendChild(node);\n                });\n              dragEnded$.subscribe(() => {\n                this.vcr.remove(this.vcr.indexOf(viewRef));\n              });\n            }\n\n            this.zone.run(() => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n\n            dragEnded$.subscribe(() => {\n              clone.parentElement!.removeChild(clone);\n              this.ghostElement = null;\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                ''\n              );\n            });\n          }\n\n          this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n\n        dragEnded$\n          .pipe(\n            mergeMap(dragEndData => {\n              const dragEndData$ = cancelDrag$.pipe(\n                count(),\n                take(1),\n                map(calledCount => ({\n                  ...dragEndData,\n                  dragCancelled: calledCount > 0\n                }))\n              );\n              cancelDrag$.complete();\n              return dragEndData$;\n            })\n          )\n          .subscribe(({ x, y, dragCancelled }) => {\n            this.zone.run(() => {\n              this.dragEnd.next({ x, y, dragCancelled });\n            });\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragActiveClass\n            );\n            currentDrag$.complete();\n          });\n\n        merge(dragComplete$, dragEnded$)\n          .pipe(take(1))\n          .subscribe(() => {\n            this.document.head.removeChild(globalDragStyle);\n          });\n\n        return pointerMove;\n      }),\n      share()\n    );\n\n    merge(\n      pointerDragged$.pipe(\n        take(1),\n        map(value => [, value])\n      ),\n      pointerDragged$.pipe(pairwise())\n    )\n      .pipe(\n        filter(([previous, next]) => {\n          if (!previous) {\n            return true;\n          }\n          return previous.x !== next.x || previous.y !== next.y;\n        }),\n        map(([previous, next]) => next)\n      )\n      .subscribe(\n        ({ x, y, currentDrag$, clientX, clientY, transformX, transformY }) => {\n          this.zone.run(() => {\n            this.dragging.next({ x, y });\n          });\n          if (this.ghostElement) {\n            const transform = `translate(${transformX}px, ${transformY}px)`;\n            this.setElementStyles(this.ghostElement, {\n              transform,\n              '-webkit-transform': transform,\n              '-ms-transform': transform,\n              '-moz-transform': transform,\n              '-o-transform': transform\n            });\n          }\n          currentDrag$.next({\n            clientX,\n            clientY,\n            dropData: this.dropData\n          });\n        }\n      );\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  private checkEventListeners(): void {\n    const canDrag: boolean = this.canDrag();\n    const hasEventListeners: boolean =\n      Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(\n          this.element.nativeElement,\n          'mousedown',\n          (event: MouseEvent) => {\n            this.onMouseDown(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen(\n          'document',\n          'mouseup',\n          (event: MouseEvent) => {\n            this.onMouseUp(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(\n          this.element.nativeElement,\n          'touchstart',\n          (event: TouchEvent) => {\n            this.onTouchStart(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchend = this.renderer.listen(\n          'document',\n          'touchend',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen(\n          'document',\n          'touchcancel',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseenter',\n          () => {\n            this.onMouseEnter();\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseleave',\n          () => {\n            this.onMouseLeave();\n          }\n        );\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove = this.renderer.listen(\n        'document',\n        'mousemove',\n        (mouseMoveEvent: MouseEvent) => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        }\n      );\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove();\n      delete this.eventListenerSubscriptions.mousemove;\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onTouchStart(event: TouchEvent): void {\n    if (!this.scrollContainer) {\n      try {\n        event.preventDefault();\n      } catch (e) {}\n    }\n    let hasContainerScrollbar: boolean;\n    let startScrollPosition: any;\n    let isDragActivated: boolean;\n    if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.scrollContainer.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n    if (!this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove = this.renderer.listen(\n        'document',\n        'touchmove',\n        (touchMoveEvent: TouchEvent) => {\n          if (\n            this.scrollContainer &&\n            this.scrollContainer.activeLongPressDrag &&\n            !isDragActivated &&\n            hasContainerScrollbar\n          ) {\n            isDragActivated = this.shouldBeginDrag(\n              event,\n              touchMoveEvent,\n              startScrollPosition\n            );\n          }\n          if (\n            !this.scrollContainer ||\n            !this.scrollContainer.activeLongPressDrag ||\n            !hasContainerScrollbar ||\n            isDragActivated\n          ) {\n            this.pointerMove$.next({\n              event: touchMoveEvent,\n              clientX: touchMoveEvent.targetTouches[0].clientX,\n              clientY: touchMoveEvent.targetTouches[0].clientY\n            });\n          }\n        }\n      );\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  private onTouchEnd(event: TouchEvent): void {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n      if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n        this.scrollContainer.enableScroll();\n      }\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  private onMouseEnter(): void {\n    this.setCursor(this.dragCursor);\n  }\n\n  private onMouseLeave(): void {\n    this.setCursor('');\n  }\n\n  private canDrag(): boolean {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  private setCursor(value: string): void {\n    this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      (this as any).eventListenerSubscriptions[type]();\n      delete (this as any).eventListenerSubscriptions[type];\n    });\n  }\n\n  private setElementStyles(\n    element: HTMLElement,\n    styles: { [key: string]: string }\n  ) {\n    Object.keys(styles).forEach(key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  private getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || document.documentElement.scrollTop,\n        left: window.pageXOffset || document.documentElement.scrollLeft\n      };\n    }\n  }\n\n  private shouldBeginDrag(\n    event: TouchEvent,\n    touchMoveEvent: TouchEvent,\n    startScrollPosition: any\n  ): boolean {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n    };\n    const deltaX =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX\n      ) - deltaScroll.left;\n    const deltaY =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY\n      ) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    if (\n      deltaTotal > this.scrollContainer.longPressConfig.delta ||\n      deltaScroll.top > 0 ||\n      deltaScroll.left > 0\n    ) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n    this.timeLongPress.timerEnd = Date.now();\n    const duration =\n      this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n    if (duration >= this.scrollContainer.longPressConfig.duration) {\n      this.scrollContainer.disableScroll();\n      return true;\n    }\n    return false;\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  OnDestroy,\n  Output,\n  EventEmitter,\n  NgZone,\n  Input,\n  Renderer2,\n  Optional\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { distinctUntilChanged, pairwise, filter, map } from 'rxjs/operators';\nimport { DraggableHelper } from './draggable-helper.provider';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\nfunction isCoordinateWithinRectangle(\n  clientX: number,\n  clientY: number,\n  rect: ClientRect\n): boolean {\n  return (\n    clientX >= rect.left &&\n    clientX <= rect.right &&\n    clientY >= rect.top &&\n    clientY <= rect.bottom\n  );\n}\n\nexport interface DropEvent<T = any> {\n  dropData: T;\n}\n\n@Directive({\n  selector: '[mwlDroppable]'\n})\nexport class DroppableDirective implements OnInit, OnDestroy {\n  /**\n   * Added to the element when an element is dragged over it\n   */\n  @Input()\n  dragOverClass: string;\n\n  /**\n   * Added to the element any time a draggable element is being dragged\n   */\n  @Input()\n  dragActiveClass: string;\n\n  /**\n   * Called when a draggable element starts overlapping the element\n   */\n  @Output()\n  dragEnter = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element stops overlapping the element\n   */\n  @Output()\n  dragLeave = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is moved over the element\n   */\n  @Output()\n  dragOver = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is dropped on this element\n   */\n  @Output()\n  drop = new EventEmitter<DropEvent>(); // tslint:disable-line no-output-named-after-standard-event\n\n  currentDragSubscription: Subscription;\n\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private renderer: Renderer2,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective\n  ) {}\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      drag$ => {\n        this.renderer.addClass(\n          this.element.nativeElement,\n          this.dragActiveClass\n        );\n        const droppableElement: {\n          rect?: ClientRect;\n          updateCache: boolean;\n          scrollContainerRect?: ClientRect;\n        } = {\n          updateCache: true\n        };\n\n        const deregisterScrollListener = this.renderer.listen(\n          this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window',\n          'scroll',\n          () => {\n            droppableElement.updateCache = true;\n          }\n        );\n\n        let currentDragDropData: any;\n        const overlaps$ = drag$.pipe(\n          map(({ clientX, clientY, dropData }) => {\n            currentDragDropData = dropData;\n            if (droppableElement.updateCache) {\n              droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n              if (this.scrollContainer) {\n                droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n              }\n              droppableElement.updateCache = false;\n            }\n            const isWithinElement = isCoordinateWithinRectangle(\n              clientX,\n              clientY,\n              droppableElement.rect as ClientRect\n            );\n            if (droppableElement.scrollContainerRect) {\n              return (\n                isWithinElement &&\n                isCoordinateWithinRectangle(\n                  clientX,\n                  clientY,\n                  droppableElement.scrollContainerRect as ClientRect\n                )\n              );\n            } else {\n              return isWithinElement;\n            }\n          })\n        );\n\n        const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n\n        let dragOverActive: boolean; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged$\n          .pipe(filter(overlapsNow => overlapsNow))\n          .subscribe(() => {\n            dragOverActive = true;\n            this.renderer.addClass(\n              this.element.nativeElement,\n              this.dragOverClass\n            );\n            this.zone.run(() => {\n              this.dragEnter.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        overlaps$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n          this.zone.run(() => {\n            this.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n\n        overlapsChanged$\n          .pipe(\n            pairwise(),\n            filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)\n          )\n          .subscribe(() => {\n            dragOverActive = false;\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragOverClass\n            );\n            this.zone.run(() => {\n              this.dragLeave.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        drag$.subscribe({\n          complete: () => {\n            deregisterScrollListener();\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragActiveClass\n            );\n            if (dragOverActive) {\n              this.renderer.removeClass(\n                this.element.nativeElement,\n                this.dragOverClass\n              );\n              this.zone.run(() => {\n                this.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      }\n    );\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { DraggableDirective } from './draggable.directive';\nimport { DroppableDirective } from './droppable.directive';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\n@NgModule({\n  declarations: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective\n  ],\n  exports: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective\n  ]\n})\nexport class DragAndDropModule {}\n"]}